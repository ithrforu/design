# О критериях резделения систем на модули

> Дэвид Лорж Парнас  
> Депортамент компьютерных наук  
> Университет Карнеги Меллон  
> Питтсбург, Пенсильвания  
> Принято в августе 1971; опубликовано в ноябре 1971  
> [Источник](https://www.engr.mun.ca/~theo/Courses/ssd/9874-downloads/Parnas-1972-criteria.pdf)  

В статье поднимается вопрос о модульности как механизме повышения гибкости и понятности системы при одновременном сокращении времени ее разработки. Эффективность модульной системы зависит от критериев, используемых при её декомпозиции на отдельные модули. В статье сформулирована проблема проектирования такой системы, и описаны традиционный и нетрадиционный подходы к декомпозиции. Показано, что нетрадиционный подход имеет явные преимущества для описанных в статье целей. Обсуждаются критерии (признаки) перечисленных подходов к декомпозиции. Нетрадиционная декомпозиция реализована с учётом общепринятого предположения о том, что модуль, состоящий из одной или нескольких подпрограмм, в большинстве случаев является менее эффективным. Реализован альтернативный набросок, доказывающий обратное.

**Ключевые слова и фразы**: программное обеспечение, модули, модульность, программная инженерия, индекс KWIC, проектирование программного обеспечения

## Введение

Яркое изложение философии модульного программирования можно найти в учебнике 1970 года по разработке программных систем Готье и Понта [1, ¶10.23]:

> Грамотно определенная сегментация проекта обеспечивает модульность системы. Каждая выполняемая задача образует явно изолированный программный модуль. В процессе сегментации определяется сам модуль и его входы, выходы. Предполагаемый интерфейс модуля не должен путаться с другими модулями системы. При отладке корректность работы модуля проверяется независимо; перед началом отладки могут возникнуть проблемы с синхронизацией задач, выполняемых различными модулями. Вся система поддерживается исходя из модульного принципа: системные ошибки и дефекты могут быть отнесены к конкретным модулям, что значительно сужает область их поиска.

Однако, исторически сложилось, что критерии разделения системы на модули не обсуждаются. В данной статье мы поднимем этот вопрос и на продемонстрированных примерах предложим такие критерии.

## Краткий отчёт

Основным достижением в области модульного программирования стала разработка методов кодирования и компиляции, которые (1) позволяют писать каждый отдельный модуль с минимальным знанием кода другого модуля и (2) позволяют собирать и заменять модули без повторной сборки всей системы.

## Предполагаемые преимущества модульного программирования

1. Сокращение времени на разработку и поддержку – над каждым модулем могут работать отдельные группы людей с малой потребностью во взаимодействии с внешней средой.
2. Гибкость продукта – возможность вносить радикальные изменения в один модуль без необходимости изменения в других.
3. Понятность – должна быть возможность изучать систему по одному модулю за раз. Вся система может быть лучше спроектирована за счёт того, что она хорошо понята.

## Что такое модульность?

Ниже приведено несколько описаний системы, называемых *модульными*. В нашем контексте «модуль» – это обособленная ответственность, а не подпрограмма. Модульная система включает в себя проектные решения, которые должны быть приняты до начала работы над независимыми модулями. По каждой из частей системы могут приниматься довольно отличающиеся друг от друга решения, но цель во всех случаях одна – описать решения «системного уровня» (то есть решения, влияющие более, чем на один модуль).

## Пример: система генерации индексов KWIC

Для целей данной статьи будет достаточно следующего описания индекса KWIC. Эта система принимает упорядоченный набор строк. Каждая строка представляет из себя упорядоченный набор слов. Каждое слово – упорядоченный набор символов. Содержимое любой строки может «двигаться по кругу» с помощью многократного удаления первого слова и добавления его в конец строки.

Это совсем небольшая система. За исключением экстремальных обстоятельств (огромная база данных, отсутствие вспомогательного ПО), она может быть создана хорошим программистом за одну-две недели. Трудности, которые могут возникнуть в процессе реализации, не вдохновляют использовать модульное программирование. Поскольку проектировать большую систему в рамках данной статьи нецелесообразно, мы потренируемся в решении данной задачи, представив, что это большой проект. Мы опишем одну модульную систему, типичную для большинства современных решений, и другую, которая успешно применялась в студенческих проектах.

### Модульная система №1

Рассмотрим следующие модули:

**Модуль 1. Ввод**. Модуль считывает строки данных с устройства ввода и сохраняет их в ядре для обработки остальными модулями. Символы упакованы по четыре, образуя слово, неиспользуемые символы используются для обозначения конца слова. Индекс будет сохраняться, чтобы показать начальный адрес каждой сроки.

**Модуль 2. Циклические перестановки**. Этот модуль будет вызван после того, как модуль ввода завершит свою работу. Он подготавливает индекс с первым символом каждой циклической перестановки и исходный индекс строки в массиве, который был получен предыдущим модулем. Модуль отдаёт ядру слова в парах с исходным номером строки и начальным адресом.

**Модуль 3. Расстановка в алфавитном порядке**. Модуль принимает в качестве входных данных массивы, созданные модулями 1 и 2, и возвращает массив в том же формате, что и модуль 2, но на выходе циклические перестановки будут представлены в алфавитном порядке.

**Модуль 4. Вывод**. Модуль принимает массивы, созданные модулями 1 и 3, и возвращает отформатированный вывод со списком всех циклических перестановок. В более сложной системе могут быть добавлены отметки с началом каждой строки или указатели на дополнительную информацию, а начало каждой циклической перестановки могло бы начинаться не с первой буквы слова в строке и так далее.

**Модуль 5. Центр управления**. Модуль не занимается ничем, кроме контроля последовательности выполнения предыдущих четырёх модулей, обработки ошибок и распределения памяти.

Разумеется, описанный выше пример не является окончательным вариантом. Прежде, чем начать работу, необходимо собрать существенно больше информации о системе. Кроме того, конечный вариант должен включать в себя ряд схем, демонстрирующих ключевые особенности системы, различные соглашения и интерфейсы всех модулей.

Данная модульная система продемонстрирована в том смысле, в каком её понимают большинство сторонников модульного программирования. Система разделена на ряд модулей с чётко определенными интерфейсами. Каждый из модулей достаточно мал и достаточно прост, чтобы его можно было легко понять и хорошо запрограммировать.

### Модульная система №2

Рассмотрим следующие модули:

**Модуль 1. Хранилище строк**. Модуль состоит из ряда функций или подпрограмм, с помощью которых его потребитель сможет им воспользоваться. Вызов функции `CHAR(r,w,c)` вернёт целое число, которое представляет `c` символ в `r` строке `w` слова. Вызов `SETCHAR(r,w,c,d)` выполнит присваивание `c` символа в `w` слове `r` строки условной переменной `d` (`d` – результат вызова `CHAR(r,w,c)`). `WORDS(r)` вернёт значение с числом слов в строке `r`. `DELINE` и `DELWRD` будут предназначены для удаления частей уже сохранённых строк. Мы не учитываем возможные ограничения, связанные с вызовом этих подпрограмм. Если пользователь выйдет за пределы этих ограничений, исключение будет «поймано» подпрограммой обработки ошибок и представлено пользователю. Модуль может быть дополнен подпрограммами, которые будут сообщать потребителю количество слов в любой строке, количество сохраняемых строк или, например, количество символов в любом слове. Точная спецификация подобного модуля представлена в [3] и [8], и мы не будем дублировать её здесь.

**Модуль 2. Ввод**. Модуль считывает данные с устройства ввода и вызывает модуль 1 для их сохранения в памяти.

**Модуль 3. Циклические перестановки**. Основные функции, представленные в этом модуле, похожи на функции, описанные в модуле 1. Он создаёт впечатление, будто мы создаём «держатель строк» не для всех строк сразу, а только для тех, которые участвуют в циклической перестановке. Таким образом, вызов `CSCHAR(i,w,c)` вернёт `c`символ в `w`слове `i` перестановки. Это означает, что (1) если `i < j`, то перестановка в строке `i` будет осуществляться перед перестановкой в строке `j`, и (2) для каждой строки первая перестановка является исходной строкой, а в вторая достигается путём сдвига на одно слово от первой перестановки и так далее. Вызов `CSSETUP` должен осуществиться до того, как другие функции будут вызваны и получат свои аргументы. C подробной спецификацией этого модуля можно ознакомиться в [8].

**Модуль 4. Расстановка в алфавитном порядке**. Модуль представлен двумя функциями. Первая, `ALPH` должна быть вызвана до того, как другая получит существующее значение. Вторая, `ITH` будет выполнять роль указателя. `ITH(i)` вернёт индекс циклической перестановки в алфавитном порядке. С более формальным определением этих функций так же можно ознакомиться в [8].

**Модуль 5. Вывод**. Модуль распечатает на экране набор строк или циклических перестановок.

**Модуль 6. Центр управления**. Аналогичен модулю 5 системы №1.

### Сравнение систем

**Общее**. Обе системы будут работать. Первая является общепринятой, вторая была успешно реализована в студенческом проекте [7]. Обе сведут процесс написания кода к относительно независимому программированию ряда маленьких и управляемым программ.

Первое. Прежде всего, обратим внимание на то, что оба подхода могут работать, используя любые представления данных и методы. Наша дискуссия касается двух разных способов декомпозиции того, что *может быть* одним и тем же объектом. Система, спроектированная в соответствии с первым подходом, *после компиляции* может быть практически идентична системе, спроектированной в соответствии со вторым.

Второе. Различия между двумя этими подходами заключаются в том, как они делят выполняемые задачи и интерфейсы между модулями. Алгоритмы, используемые в обоих кейсах *могут быть* идентичны. Системы существенно отличаются несмотря на то, что они практически идентичны в рантайме. Это возможно, так как рантайм «существует» только после запуска программы. Иные представления используются для внесения изменений, документирования, понимания системы и так далее. Две наши системы не являются идентичными в других, помимо рантайма, представлениях.

**Причины для изменений**. Существует ряд проектных решений, которые остаются под вопросом, потому что могут меняться при различных обстоятельствах. Это неполный их список:

1. Формат ввода.

2. Решение о том, будут ли строки храниться в ядре. При большом объеме данных, хранение всех строк в ядре может оказаться нецелесообразным.

3. Решение о том, будут ли символы скомпонованы по четыре на каждое слово. В случаях, когда мы работаем с небольшими объемами данных, такое действие может быть нежелательно, потому что символы могут храниться в словоформе. В остальных случаях, мы могли бы компоновать слова иначе.

4. Решение об использовании индекса циклических перестановок вместо хранения их самих. Для небольшого количества перестановок или объемного ядра хранение перестановок может быть предпочтительным подходом. В таком случае, мы можем не выполнять подготовку индекса в `CSSETUP`. Вместо этого, все вычисления могут быть выполнены в процессе вызова других функций (например, `CSCHAR`).

5. Решение о сортировке списка в алфавитном порядке один раз вместо (а) поиска каждого элемента, когда это необходимо, или (б) использования частичной сортировки по алфавиту по аналогии с сортировкой Хоара [2]. При определённых обстоятельствах, для принятия решения, также имеет смысл сравнить время, необходимое для сортировки по алфавиту, и время, необходимое на создание индекса.


Рассматривая эти причины для изменений (далее изменения), становится проще заметить разницу между двумя подходами. Первое изменение ограничивается одним модулем в обоих системах. Второе изменение в первом подходе потребует изменения во всех модулях! Аналогично и для третьего изменения. В первом подходе способ хранения строк в ядре затрагивает все подпрограммы. Cитуация кардинально отличается во втором подходе: cпособ хранения строк скрыт от всех, кроме модуля 1, и любые изменения способа хранения будут ограничены этим модулем!

В некоторых версиях рассмотренной нами системы используется дополнительный модуль. Модуль таблицы символов (рассмотрен в [3]) использовался нами в модуле хранения строк. Этот факт незаметен для остальной части системы.

Четвертое изменение в случае второго подхода ограничено модулем, отвечающим за циклические перестановки. В первом подходе модули, ответственные соответственно за сортировку по алфавиту и вывод, будут знать об изменении.

Пятое изменение тоже будет сложнее в случае первого подхода – модуль вывода ожидает, что индекс подготовлен до начала выполнения модуля. Во втором подходе модуль сортировки по алфавиту был разработан таким образом, чтобы потребитель не мог определить когда именно выполняется сортировка. В случае правок, никакие другие модули менять не придётся.

**Независимая разработка**. В первом подходе интерфейсы между модулями имеют сложный формат – это проектные решения, которые не могут быть приняты «на лету». Структура и организация важны для каждого отдельного модуля и должны быть тщательно продуманы. Процесс проектирования этих интерфейсов будет основным этапом разработки модуля, и этот этап является совместной работой нескольких групп разработчиков. Во втором подходе интерфейсы более абстрактны – они состоят, в основном, из имён функций и количества/типов передаваемых параметров. Проектирование интерфейсов, в этом случае, будет сопровождаться более лёгкими решениями, а независимая разработка начнётся гораздо раньше.

**Понятность**. Чтобы понять как работает модуль вывода в первом подходе, необходимо разобраться ещё и с модулями сортировки по алфавиту, циклических перестановок и ввода. В отдельном модуле найдутся аспекты со смыслом, обусловленным лишь тем, как работают другие модули. Структуры данных будут ограничены алгоритмами, используемыми в других модулях. Система будет понятна только в целом. С моей субъективной точки зрения, это не касается второго подхода.

### Критерии

Читатели могли заметить какие именно критерии использовались в каждом подходе к декомпозиции. В первом критерием было основное действие программы, которое осуществлялось отдельным модулем. Для реализации такой декомпозиции нужно составить блок-схему (наиболее распространённый подход). Это общепринятый процесс обучения программистов, который учит нас тому, что разработка должна начинаться с грубой блок-схемы и от неё двигаться к деталям реализации. Блок-схема является полезной абстракцией для систем с 5 000 - 10 000 тысячами инструкций, но, по мере продвижения вперёд, она становится недостаточной, и требуется нечто иное.

Декомпозиция во втором подходе была выполнена с учётом критерия о «сокрытии информации» [4]. Отдельные модули больше не соответствуют этапам работы программы. Например, модуль хранения строк используется почти в каждом действии системы. Сортировка по алфавиту тоже может выполняться не на этапе обработки, а в соответствии используемому методу. Точно так же циклическая перестановка может вообще не создавать таблицы, а вычислять каждый символ по мере необходимости. Каждый модуль во втором подходе характеризуется знанием проектного решения, которое сокрыто ото всех остальных. Интерфейс и реализация сделаны таким образом, чтобы раскрывать как можно меньше деталей о внутренней работе модуля.

### Улучшение модуля циклических перестановок

Чтобы проиллюстрировать влияние данного критерия, давайте подробнее рассмотрим структуру модуля циклических перестановок из второго подхода к декомпозиции. Оглядываясь назад, может возникнуть предположение о том, что модуль раскрывает больше информации, чем это необходимо. В процессе сокрытия способа хранения и расчёта списка циклических перестановок, в этом списке мы указали их порядок. Программа станет ещё более эффективной, если мы укажем, (1) что все строки, относящиеся к текущей циклической перестановке, существуют в таблице, (2) что ни одна из строк не будет включена дважды, и (3) что существует дополнительная функция, которая позволит идентифицировать исходную строку с учётом сдвига. Указав порядок перестановок заранее, мы раскрыли больше информации, чем нужно, и из-за этого излишне ограничили класс систем, которые мы можем построить, не меняя реализацию. Например, мы не учли систему, в которой циклические перестановки производятся не в алфавитном порядке, что в `ALPH` может вернуть пустой результат, и что `ITH` может возвращать свой аргумент как значение. С точки зрения второго подхода эти факты однозначно классифицируется как ошибка проектирования.

Помимо общих критериев, заключающихся в сокрытии какого-либо проектного решения от остальной системы, стоит упомянуть некоторые другие подходы, которые тоже кажутся целесообразными:

1. *Структура данных, её внутренние связи, доступ и и процесс изменений* как часть конкретного модуля. Они не используются многими модулями, как это обычно происходит. Это предположение, возможно, является развитием идей, лежащих в основе работ Бальцера [9] и Мили [10]. Думаю, дизайн BLISS [11] также явно предшествует дизайну с нашим подходом.

2. *Последовательность инструкций, необходимых для вызова подпрограммы, и сама подпрограмма являются частью одного и того же модуля*. Это правило не имеет отношения к Фортрану, который мы использовали для экспериментов, но является важным для систем, построенных на языке ассемблера. Не существует идеальных общих последовательностей вызовов для реальных машин, и, следовательно, они имеют тенденцию меняться по мере того, как поиск идеальной последовательности продолжается.

3. *Форматы управляющих конструкций*, используемых в очередях операционных систем и соответствующие им программы *должны быть скрыты* в модуле блока управления. Такие форматы принято делать интерфейсами между различными модулями. Однако, поскольку эволюция дизайна требует частых изменений в форматах управляющий конструкций, такое решение чаще всего оказывается чрезвычайно дорогостоящим.

4. *Коды символов, сортировка в алфавитном порядке и подобные данные должны быть скрыты* в отдельных модулях для достижения максимальной гибкости.

5. Последовательность, в которой обрабатываются определённые элементы, должна быть, насколько это возможно, скрыта внутри одного модуля. Разного рода различия, от добавления оборудования до недоступности определённых ресурсов в операционной системе, делают эту последовательность чрезвычайно многоликой.

### Эффективность и имплементация

Если не быть осторожным, второй подход к декомпозиции окажется намного менее эффективным, чем первый. Если каждая из функций реализована как процедура со сложной последовательностью вызовов, то вызовов получится также много из-за многократного переключения между модулями. Первый подход к декомпозиции не будет страдать этим недостатком, так как передача управления между модулями происходит относительно редко.

Чтобы сократить накладные расходы на вызов процедуры, но получить преимущества, которые были описаны выше, мы должны реализовать модули нетривиальным способом. Иногда в подпрограммах лучше всего использовать код на ассемблере, но иногда целесообразнее воспользоваться узкоспециализированным и эффективным процессом сборки. Для эффективного использования второго подхода к декомпозиции потребуется инструмент, с помощью которого программу получится написать так, как если бы функции были отдельными подпрограммами, но были собраны в любой подходящей и сохраняющей функциональность реализации. Если используется такой инструмент, то в конечном коде разделение между модулями может быть размытым. Поэтому пригодится программа, с помощью которой будет удобно вносить изменения. Иначе говоря, несколько упомянутых ранее представлений программы должны поддерживаться и храниться вместе с программой, осуществляющей сборку и навигацию между ними.

### Декомпозиция, общая для компилятора и интерпретатора одного и того же языка

В более ранней попытке применить эти правила декомпозиции к дизайн-проекту мы построили транслятор для алгоритма Маркова, описанного в [6]. Хотя исследование связи между компилируемым и интерпретируемым транслятором не входило в наши намерения, мы обнаружили, что наша декомпозиция верна для чистого компилятора и нескольких разновидностей интерпретатора. Не смотря на то, что в рабочем представлении каждого типа компилятора будут существенные различия, мы обнаружили, что решения, заложенные в ранней декомпозиции, справедливы для всех.

Всё было бы иначе, если бы мы разделили ответственность классическим образом для компилятора или интерпретатора (например, распознаватель синтаксиса, генератор кода, подпрограммы времени выполнения компилятора). Вместо этого, декомпозиция была основана на сокрытии различных решений, как в примере выше. Таким образом, представление регистров, алгоритм поиска, интерпретация правил и т.д. являлись модулями, и все эти задачи существовали как в компилируемом, так и в интерпретируемом трансляторе. Кроме того, что декомпозиция была верна во всех случаях, большинство подпрограмм можно было использовать с небольшими изменениями в трансляторе любого типа.

Этот пример является дополнительным аргументом к утверждению о том, что порядок, в котором ожидается выполнение программы, не должен быть критерием при декомпозиции системы на модули. Кроме того, это является подтверждением того, что тщательная работа по декомпозиции может способствовать более простому переносу результата работы из одного проекта в другой.

С более подробным обсуждением этого примера можно ознакомиться в [8].

## Иерархическая структура

Рассмотрим программную иерархию, проиллюстрированную Дейкстрой [5] в системе, определённой в соответствии со вторым подходом к декомпозиции. Если таблица символов существует, то она способна функционировать без каких-либо других модулей, и, следовательно, находится на уровне 1. Хранилище строк находится на уровне 1, если таблица символов не используется (иначе она будет находиться на уровне 2). Модулю ввода и модулю циклических перестановок для корректной работы необходимо хранилище строк. Для модуля вывода и модуля сортировки по алфавиту требуется модуль циклических перестановок, но пока модуль циклических перестановок и хранилище строк совместимы между собой, будет легко создать параметризированную версию этих подпрограмм, которая сможет использоваться для сортировки по алфавиту, вывода исходных строк либо циклических перестановок. В первом подходе модуль циклических перестановок им не потребуется, во втором наоборот. Другими словами, наш дизайн позволил нам иметь единое представление для программ, которые выполняются на любом из двух уровней иерархии.

Обсуждая структуру системы легко спутать преимущества хорошей декомпозиции с преимуществами иерархической структуры. Мы имеем иерархическую структуру, если между модулями или программами может быть определено отношение, и это отношение является частично упорядоченным. Нас же интересует отношение между «использовать» и «зависеть от». Лучше всего использовать отношение «зависеть от», поскольку чаще всего модуль зависит лишь от части другого модуля (например, модуль циклических перестановок зависит только от выходной части модуля хранилища строк, а не от правильной работы `SETWORD`). Вполне допустимо, что мы смогли бы получить преимущества, которые обсуждали, без частичного упорядочивания, то есть если бы все модули были на одном уровне. Частичное упорядочивание даёт два дополнительных преимущества: во-первых, части программы становятся за счёт того, что они используются только частями более «низких» уровней, во-вторых, мы можем переиспользовать некоторые из верхних уровней и по-прежнему получать полезный продукт. Например, таблицу символов можно использовать в других приложениях, а модуль сохранения строк может быть основой системы ответов на вопросы. Иерархическая структура гарантирует, что мы можем «обрезать» верхние уровни дерева и начинать растить новое дерево на старом стволе. Если бы мы разработали систему, в которой модули «низкого» уровня частично используют модули «высокого», у нас не было бы иерархии, и нам было бы гораздо труднее удалять части системы, а само понятие уровня в нашей системе было бы бессмысленно.

Поскольку вполне вероятно, что у нас могла бы быть система из первого подхода к докомпозиции (с важными проектными решениями об интерфейсах), но с сохранением иерархической структуры, мы можем сделать вывод о том, что иерархическая структура и «чистая» декомпозиция являются двумя важными, но *независимыми* свойствами системы.

## Заключение

На разобранных примерах мы попытались показать, что начинать разделение системы на модули с блок-схемы чаще всего некорректно. Вместо этого мы предлагаем начинать со списка сложных проектных решений или же проектных решений, которые могут измениться в будущем. Каждый модуль предназначен для того, чтобы скрыть такое решение от других модулей. Поскольку в большинстве случаев проектные решения выходят за рамки времени выполнения программы, модули не будут соответствовать этапам её выполнения. Чтобы добиться эффективной реализации, мы должны отказаться от предположения о том, что модуль представляет собой одну или несколько подпрограмм, и вместо этого позволить подпрограммам брать код из других модулей.

### Список литературы
1. Gauthier, Richard, and Pont, Stephen. *Designing Systems Programs*, (C), Prentice-Hall, Englewood Cliffs, N.J., 1970.
2. Hoare, C. A. R. Proof of a program, FIND. *Comm. ACM 14, 1* (Jan. 1971), 39-45.
3. Parnas, D. L. A technique for software module specification with examples. *Comm. ACM 15, 5* (May, 1972), 330-336.
4. Parnas, D. L. Information distribution aspects of design methodology. Tech. Rept., Depart. Computer Science, Carnegie-Mellon U., Pittsburgh, Pa., 1971. Also presented at the IFIP Congress 1971, Ljubljana, Yugoslavia.
5. Dijkstra, E. W. The structure of "THE"-multiprogramming system. *Comm. ACM 11, 5* (May 1968), 341-346.
6. Galler, B., and Perlis, A. J. *A View of Programming Languages*, Addison-Wesley, Reading, Mass., 1970.
7. Parnas, D. L. A course on software engineering. Proc. SIGCSE Technical Symposium, Mar. 1972.
8. Parnas, D. L. On the criteria to be used in decomposing systems into modules. Tech. Rept., Depart. Computer Science, Carnegie-Mellon U., Pittsburgh, Pa., 1971.
9. Balzer, R. M. Dataless programming. Proc. AFIPS 1967 FJCC, Vol. 31, AFIPS Press, Montvale, N.J., pp. 535-544.
10. Mealy, G. H. Another look at data. Proc. AFIPS 1967 FJCC, Vol. 31, AFIPS Press, Montvale, N.J., pp. 525-534.
11. Wulf, W. A., Russell, D. B., and Habermann, A. N. BLISS, A language for systems programming. *Comm. ACM 14, 12* (Dec. 1971), 780-790.

> Communications of the ACM  
> Декабрь 1972  
> Выпуск 15  
> Номер 12  