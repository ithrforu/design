# О критериях резделения систем на модули

> Дэвид Лорж Парнас
> Депортамент компьютерных наук
> Университет Карнеги Меллон
> Питтсбург, Пенсильвания
> Источник: https://www.engr.mun.ca/~theo/Courses/ssd/9874-downloads/Parnas-1972-criteria.pdf

В статье обсуждается модуляризация как механизм повышения гибкости и понятности системы при одновременном сокращении времени ее разработки. Эффективность «модуляризации» зависит от критериев, используемых при разделении системы на модули. В статье сформулирована проблема проектирования системы и описаны как традиционная, так и нетрадиционная декомпозиция. Показано, что нетрадиционная декомпозиция имеет явные преимущества для описанных целей. Обсуждаются критерии достижения перечисленных видов декомпозиции. Нетрадиционная декомпозиция реализована с учётом обыденного предположения о том, что модуль, состоящий из одной или нескольких подпрограмм, в большинстве случаев является менее эффективным. Сделан набросок альтернативного подхода к реализации, доказывающий обратное.

**Ключевые слова и фразы**: программное обеспечение, модули, модульность, программная инженерия, индекс KWIC, проектирование программного обеспечения

## Введение

Яркое изложение философии модульного программирования можно найти в учебнике 1970 года по разработке программных систем Готье и Понта [1, ¶10.23]:

> Чётко определенная сегментация проекта обеспечивает модульность системы. Каждая задача образует явно изолированный программный модуль. В процессе реализации определяется каждый модуль и его входы и выходы, предполагаемый интерфейс не путается с другими модулями системы. При отладке целостность модуля проверяется независимо; при планировании могут возникнуть проблемы с синхронизацией задач перед началом отладки. Вся система поддерживается исходя из модульного принципа: системные ошибки и дефекты могут быть отнесены к конкретным модулям, что значительно сужает область поиска ошибок.

Как правило, критерии разделения системы на модули не обсуждаются. В данной статье мы поднимем этот вопрос и на примерах предложим критерии, которые можно использовать при разбиении системы на модули.

## Краткий отчёт

Основным достижением в области модульного программирования стала разработка методов кодирования и компиляции, которые (1) позволяют писать каждый отдельный модуль с минимальным знанием кода другого модуля и (2) позволяют собирать и заменять модули без повторной сборки всей системы.

## Предпологаемые преимущества модульного программирования

Преимущества, ожидаемые от модульного программирования:
1. Сокращение времени на разработку и администрирование — над каждым модулем могут работать отдельные группы с небольшой потребностью в общении с внешней средой.
2. Гибкость продукта — возможность вносить радикальные изменения в один модуль без необходимости изменения в других.
3. Понятность — должна быть возможность изучать систему по одному модулю за раз. Вся система может быть лучше спроектирована за счёт того, что она лучше понята.

## Что такое модуляризация?

Ниже приведено несколько описаний системы, называемых *модуляризациями*. В этом контексте «модуль» — это обособленная ответственность, а не подпрограмма. Модуляризации включают в себя проектные решения, которые должны быть приняты до начала работы над независимыми модулями. По каждой из частей системы могут приниматься довольно отличающиеся друг от друга решения, но цель во всех случаях одна — описать все решения «системного уровня» (т.е. решения, влияющие более, чем на один модуль).

## Пример: система производства индексов KWIC.

Для этой статьи достаточно следующего описания индекса KWIC. Система индексов KWIC принимает упорядоченный набор строк, каждая строка представляет собой упорядоченный набор слов, а каждое слово представляет собой упорядоченный набор символов. Любая строка может «двигаться по кругу» с помощью многократного удаления первого слова и добавления его в конец строки.

Это маленькая система. За исключением экстремальных обстоятельств (огромная база данных, отсутствие вспомогательного ПО), такая система может быть создана хорошим программистом за одну-две недели. Трудности, которые могут возникнуть в процессе реализации, не мотивируют использовать модульное программирование. Однако, поскольку проектировать большую систему в рамках данной статьи нецесообрано, мы можем потренироваться в решении задачи, как будто это большой проект. Мы опишем одну модуляризацию, типичную для современных решений, и другую, которая успешно применялась в студенческих проектах.

### Модуляризация №1

Рассмотрим следующие модули:

**Модуль 1: Ввод**. Данный модуль считывает строки данных с устройства ввода и сохраняет их в ядре для обработки остальными модулями. Символы упакованы по четыре, образуя слово, лишние символы используются для обозначения конца слова. Индекс сохраняется, чтобы показать начальный адрес каждой сроки.

**Модуль 2. Циклические перестановки**. Этот модуль будет вызыван после того, как модуль ввода завершит свою работу. Он подготавливает индекс с первым символом каждой циклической перестановки и исходный индекс строки в массиве, который был получен модулем 1. Модуль отдаёт ядру слова в парах с исходным номером строки и начальным адресом.

**Модуль 3. Расстановка в алфавитном порядке**. Модуль принимает в качестве входных данных массивы, созданные модулями 1 и 2. Он создает массив в том же формате, что и модуль 2, но на выходе циклические перестановки представлены в алфавитном порядке.

**Модуль 4. Вывод**. Модуль использует массивы, созданные модулем 3 и 1, и создаёт отформатированный вывод со списком всех циклических перестановок. В более сложной системе могли быть добавлены отметки с началом каждой строки, указатели на дополнительную информацию, начало каждой циклической перестановки могло бы начинаться не с первой буквы слова в строке и так далее.

**Модуль 5: Центр управления**. Модуль не занимается ничем, кроме контроля последовательности выполнения других четырёх модулей, обработки ошибок и распределения пространства.

Очевидно, что описанный выше пример не является окончательным вариантом. Прежде, чем начать работу необходимо гораздо больше информации о системе. Кроме того, конечный вариант должен включать в себя ряд рисунков, демонстрирующих ключевые моменты, различные соглашения и интерфейсы всех четырёх модулей.

Данное модуляризация представлена в том смысле, в каком её понимают большинство сторонников модульного программирования. Система разделена на ряд модулей с чётко определенными интерфейсами. Каждый из модулей достаточно мал и достаточно прост, чтобы его можно было легко понять и хорошо запрограммировать.

### Модуляризация №2

Рассмотрим следующие модули:

**Модуль 1: Хранилище строк**. Модуль состоит из ряда функций или подпрограмм, с помощью которых пользователь модуля сможет им воспользоваться. Вызов функции `CHAR(r,w,c)` вернёт целое число, которое представляет `c` символ в `r` строке `w` слова. Вызов `SETCHAR(r,w,c,d)` выполнит присвоение `c` символа в `w` слове `r` строки условной переменной `d` (`d` – это результат вызова `CHAR(r,w,c)`). `WORDS(r)` вернёт значение с числом слов в строке `r`. Функции `DELINE` и `DELWRD` будут предназначены для удаления частей уже сохранённых строк. Мы не учитываем возможные ограничения, связанные с вызовом этих подпрограмм. Если пользователь выйдет за пределы этих ограничений, то вызванная им подпрограмма будет "поймана" подпрограммой обработки ошибок и представлена пользователю. Модуль может быть дополнен подрограммами, которые будут сообщать вызывающему количество слов в любой строке, количество сохраняемых строк или, например, количество символов в любом слове. Точная спецификация подобного модуля представлена в [3] и [8], и мы не будем дублировать её здесь.

**Module 2: Ввод**. Модуль считывает данные с устройства ввода и вызывает модуль 1 для их сохранения в памяти.

**Модуль 3. Циклические перестановки**. Основные функции, представленные этим модулем аналогичны функциям, описанным в модуле 1. Модуль создаёт впечатление, будто мы создаём "держатель строк" не для всех строк, а только для тех, которые участвуют в циклической перестановке. Таким образом, вызов `CSCHAR(i,w,c)` вернёт значение, представляющее собой `c`символ в `w`слове `i` перестановки. Это означает, что (1) если `i < j`, то перестановка в строке `i` будет осуществляться перед перестановкой в строке `j`, и (2) для каждой строки первая перестановка является исходной строкой, а в вторая перестановка достигается путём сдвига на одно слово от первой перестановки и так далее. Вызов `CSSETUP` должен осуществляться до того, как другие функции будут вызваны и получат свои аргументы. C ,олее подробной спецификацией этого модуля можно ознакомиться в [8].

**Модуль 4. Расстановка в алфавитном порядке**. Модуль представлен двумя функциями. Первая, `ALPH` должна быть вызвана до того, как другая получит существующее значение. Вторая, `ITH` будет выполять роль указателя. `ITH(i)` вернёт индекс циклической перестановки, которая идёт в алфавитном порядке. Более формальное пределение этих функции также находится в [8].

**Module 5: Вывод**. Модуль распечатает на экране набор строк или циклических перестановок.

**Module 6: Центр управления**. Аналогичен модулю 5 первой модуляризации.

### Сравнение двух модуляризаций

**Общее**. Обе схемы будут работать. Первая является более условной, вторая была успешно реализована в студенческом проекте [7]. Обе схемы сведут процесс написания кода к относительно независимому программированию ряда маленьких и управляемым программ.

Прежде всего, нужно обратить внимание на то, что оба подхода к декомпозиции могут совместно работать, используя любые представления данных и методы доступа. Наша дискуссия касается двух разных способов разделения того, что *может быть* одним и тем же объектом. Система, спроектированная в соответствии с первой модуляризацией *после компиляции* может быть практически идентична системе, спроектированной в соответствии со второй модуляризацией.

Второе. Различия между двумя вариантами заключаются в том, как они делят выполняемую работу и интерфейсы между модулями. Алгоритмы, используемые в обоих кейсах *могут быть* идентичны. Системы существенно отличаются несмотря на то, что они практически идентичны в рабочем представлении (рантайме), это возможно, так как рабочее представление "выполняется" только после запуска программы. Иные представления используются для внесения изменений, документирования, понимания системы и так далее. Две наши системы не являются идентичными в других, помимо рабочего, представлениях.

**Причины для изменений**. Существует ряд проектных решений, которые остаются под вопросом, потому что могут меняться при различных обстоятельствах. Это неполный их список:

1. Формат ввода.
2. Решение о том, будут ли строки храниться в ядре. При большом объеме данных сохранение всех строк в ядре может оказаться неудобным или непрактичным.
3. Решение о том, будут ли символы скомпанованы по четыре на каждое слово. В случаях, когда мы работаем с небольшими объемами данных, такое действие может быть нежелательно, потому что символы могут храниться в макете слова. В остальных случаях, компановка может потребоваться, но в другом формате.
4. Решение об использовании индекса для циклических перестановок вместо хранения их как таковых. Для небольшого количества перестановок или объемного ядра хранение перестановок может быть предпочтительным подходом. В таком случае, мы можем не выполнять подготовку индекса в `CSSETUP`. Вместо этого, все вычисления могут быть выполнены в процессе вызова других функций (например, `CSCHAR`).
5. Решение отсортировать список в алфавитном порядке один раз вместо (а) поиска каждого элемента, когда это необходимо, или (б) использования частичной сортировки по алфавиту по аналогии с сортировкой Хоара [2]. При определённых обстоятельствах, для принятия решения, также имеет смысл сравнить время, необходимое для сортировки по алфавиту, и время, необходимое на создание индекса.


Рассматривая эти причины для изменений (далее изменения), мы можем увидеть разницу между двумя модуляризациями. Первое изменение ограничивается одним модулем в обоих модуляризациях. Второе изменение при первом варианте декомпозиции потребует изменения во всех модулях! Аналогично и для третьего изменения. В первом варианте декомпозиции способ хранения строк в ядре затрагивает все подпрограммы. Cитуация координально отличается для второго варианта декомпозиции: cпособ хранения строк скрыт ото всех, кроме модуля 1, любые изменения способа хранения будут ограничены этим модулем!

В некоторых версиях рассмотренной нами системы используется дополнительный модуль. Модуль таблицы символов (рассмотрен в [3]) использовался нами в модуле хранения строк. Этот факт незаметен для остальной части системы.

Четвертое изменение в случае второй декомпозиции ограничено модулем, отвечающим за циклические перестановки. В первой декомпозиции модули, ответственные соответственно за сортировку по алфавиту и вывод, также будут знать об изменении.

Пятое изменение также будет сложнее в случае первой декомпозиции – модуль вывода ожидает, что индекс подготовлен до начала выполнения модуля. Во второй декомпозиции модуль сортировки по алфавиту был разработан таким образом, чтобы пользователь не мог определить когда именно выполняется сортировка. В случае правок, никакие другие модули менять не придётся.

**Независимая разработка**. В первой модуляризации интерфейсы между модулями имеют сложный формат – они представляют собой проектные решения, которые не могут быть легко приняты. Структура и организация важны для каждого отдельного модуля и должны быть тщательно спроектированы. Процесс проектирования этих интерфейсов будет основной частью разработки модуля, и эта часть является совместной работой нескольких групп разработчиков. Во второй модуляризации интерфейсы более абстрактны – они состоят, в основном, из имён функций и количества/типов передаваемых параметров. Проектирование интерфейсов, в этом случае, будет сопровождаться более простыми решениями, а независимая разработка начнётся гораздо раньше.

**Понятность**. Чтобы понять как работает модуль вывода в первой модуляризации, необходимо разобраться также и с модулями сортировки по алфавиту, циклических перестановок и модулем ввода. В отдельном модуле найдутся аспекты со смыслом, обусловленным лишь тем, как работают другие модули. Структуры данных будут ограничены алгоритмами, используемыми в других модулях. Система будет понятна только в целом. С моей субъективной точки зрения, это не касается второй модуляризации.

### Критерии

Теперь многие читатели увидят, какие критерии использовались в каждой декомпозиции. В первой декомпозиции критерием было основное действие программы, которое осуществлялось отдельным модулем. Для составления такой декомпозиции нужно составить блок-схему, это наиболее распространённый подход к декомпозиции или модуляризации. Это общий результат обучения программистов, который учит нас тому, что процесс разработки должен начинаться с грубой блок-схемы и от неё двигаться к более подробной реализации. Блок-схема является полезной абстракцией для систем с 5 000-10 000 тысячями инструкций, но, по мере продвижения вперёд, она становится недостаточной, и требуется нечто иное.

Вторая декомпозиция была выполнена с использованием критерия «сокрытие информации» [4]. Отдельные модули больше не соответствуют этапам работы программы. Например, модуль хранения строк используется почти в каждом действии системы. Сортировка по алфавиту также может выполняться не на этапе обработки, а в соответствии с используемым методом. Точно также циклическая перестановка может вообще не создавать таблицы, а вычислять каждый символ по мере необходимости. Каждый модуль во второй декомпозиции характеризуется знанием проектного решения, которое скрыто ото всех остальных. Интерфейс и определение выбраны таким образом, чтобы расскрывать как можно меньше деталей о внутренней работе модуля.

### Улучшение в модуле циклических перестановок

Чтобы проиллюстрировать влияние данного критерия, давайте более подробно рассмотрим структуру модуля циклических перестановок из второй декомпозиции. Оглядываясь назад, можно предположить, что определение модуля раскрывает больше информации, чем необходимо. Пока мы тщательно скрывали способ хранения и расчёта списка циклических перестановок, мы указали порядок в этом списке. Программа станет более эффективной, если мы укажем, (1) что все строки, относящиеся к текущей циклической перестановке, будут существовать в таблице, (2) что ни одна из строк не будет включена дважды, и (3) что существует дополнительная функция, которая позволит идентифицировать исходную строку с учётом сдвига. Предписывание порядок смен заранее, мы дали больше информации, чем нужно, и тем самым излишне ограничили класс систем, которые мы можем построить, не меняя определений. Например, мы не учли систему, в которой циклические перестановки прозводятся не в алфавитном порядке, что в `ALPH` может быть пусто, и что `ITH` может возвращать свой аргумент как значение. С точки зрения второй декомпозиции этот факт однозначно классифицируется как ошибка проектирования.

Помимо общих критериев, которые заключаются в сокрытии какого-либо проектного решения от остальной системы, стоит упомянуть некоторые конкретные примеры декомпозиций, которые также кажутся целесообразными:

1. *Стурктура данных, её внутренние связи, доступ и модификации* как часть конкретного модуля. Они не используются многими модулями, как это обычно делается. Это определение, возможно, является развитием предположений, лежащих в основе работ Бальцера [9] и Мили [10]. Думаю, дизайн BLISS [11] явно предшествует дизайну с нашим определением.

2. *Последовательность инструкций, необходимых для вызова данной подпрограммы, и сама подпрограмма являются частью одного и того же модуля*. Это правило не имеет отношения к Фортрану, который мы использователи для экспериментов, но является важным для систем, построенных на языке ассемблера. Не существует идеальных общих последовательностей вызовов для реальных машин, и, следовательно, они имеют тенденцию меняться по мере того, как поиск идельной последовательности продолжается.

3. *Форматы управляющих блоков*, используемых в очередях операционных систем и соответствующие им программы *должны быть скрыты* в модуле блока управления. Такие форматы принято делать интерфейсами между различными модулями. Однако, поскольку эволюция дизана требует частых изменений в форматах блоков управления, такое решение чаще всего оказывается чрезвычайно дорогостоящим.

4. *Коды символов, сортировка в алфавитном порядке и подобные данные должны быть скрыты* в отдельных модулях для достижения максимальной гибкости.

5. Последовательность, в которой обрабатываются определённые элементы, должна быть, насколько это возможно, скрыта внутри одного модуля. Разного рода различия, от добавления оборудования до недоступности определённых ресурсов в операционной системе, делают эту последовательность чрезвычайно разнообразной.

### Эффективность и внедрение

Если не быть осторожным, вторая декомпозиция окажется намного менее эффективной, чем первая. Если каждая из функций реализована как процедура со сложной последовательностью вызовов, таких вызовов будет много из-за многократного переключения между модулями. Первая декомпозиция не будет страдать от этого недостатка, так как передача управления между модулями происходит относительно редко. Чтобы сократить накладные расходы на вызов процедуры, но получить преимущества, которые были описаны выше, мы должны реализовать модули необычным способом. Во многих случаях в подпрограммах лучше всего использовать код на ассемблере, в других случаях можно пользоваться ускоспециализированными и эффективными "переводами". Для эффективного использования второго типа декомпозиции потребуется инструмент, с помощью которого программу получится написать так, как если бы функции были отдельными подпрограммами, но были собраны в любой подходящей и сохраняющей функционал реализации. Если такой инструмент используется, то в конечном коде разделение между модулями может быть размытым. Может быть полезна программа, с помощью которой будет удобно добавлять новые модификации. Другими словами, несколько упомянутых ранее представлений программы должны поддерживаться вместе с программой, осуществляющей сборку и навигацию между ними.

### Декомпозиция, общая для компилятора и интерпретатора одного и того же языка

В более ранней попытке применить эти правила декомпозиции к дизайн-проекту мы построили транслятор для алгортима Маркова, описанного в [6]. Хотя исследование связи между компилируемым и интерпретируемым транслятором не входило в наши намерения, мы обнаружили, что наша декомпозиция верна для чистого компилятора и нескольких разновидностей интерпретатора. Не смотря на то, что в рабочем представлении каждого типа копилятора будут существенные различия, мы обнаружили, что решения, заложенные в ранней декомпозиции, справедливы для всех.

Всё было бы иначе, если бы мы разделили ответственность классическим образом для компилятора или интерпретатора (например, распознователь синтаксиса, генератор кода, подпрограммы времени выполнения компилятора). Вместо этого, декомпозиция была основана на сокрытии различных решений, как в примере выше. Таким образом, представление регистров, алгоритм поиска, интерпретация правил и т.д. являлись модулями, и все эти задачи существовали как в компилируемом, так и в интерпретируемом трансляторе. Кроме того, что декомпозиция была верна во всех случаях, большинство подпрограмм можно было использовать с небольшими изменениями в трансляторе любого типа.

Этот пример является дополнительным аргументом к утверждению о том, что порядок, в котором ожидается выполнение программы, не должен быть критерием при декомпозиции системы на модули. Также, это является подтверждением того, что тщательная работа по декомпозиции может способствовать более простому переносу работы из одного проекта в другой.

Более подробное обсуждение этого примера находится в [8].

## Иерархическая структура

Мы можем разглядеть программную иерархию, проиллюстрированную Дейкстрой [5] в системе, определённой в соответствии со второй декомпозицией. Если таблица символов существует, то она способна функционировать без каких-либо других модулей, и, следовательно, находится на уровне 1. Хранилище строк находится на уровне 1, если таблица символов не используется, иначе она будет находиться на уровне 2. Модулю ввода и модулю циклических перестановок для своей корректной работы необходимо хранилище строк. Для модуля вывода и модуля сортировки по алфавиту требуется модуль циклических перестановок, но пока модуль циклических перестановок и хранилище строк совместимы между собой, будет легко создать параметризированную версию этих подпрограмм, которая сможет использоваться для сортировки по алфавиту, вывода исходных строк либо циклических перестановок. В первом варианте использования модуль циклических перестановок им не потребуется, во втором наоборот. Другими словами, наш дизайн позволил нам иметь единое представление для программ, которые могут выполняться на любом из двух уровней иерархии.

Обсуждая структуру системы легко спутать преимущества хорошей декомпозиции с преимуществами иерархической структуры. Мы имеем иерархическую структуру, если между модулями или программами может быть определено определённое отношение, и это отношение является частично упорядоченным. Нас же интересует соотношение между «использовать» или «зависеть от». Лучше всего использовать отношение «зависеть от», поскольку чаще всего модуль зависит лишь от части другого модуля (например, модуль циклических перестановок зависит только от выходной части модуля хранилища строк, а не от правильной работы `SETWORD`). Вполне допустимо, что мы смогли бы получить преимущества, которые обсуждали, без частичного упорядочивания, то есть если бы все модули были на одном уровне. Частичное упорядочивание даёт два дополнительных преимущества: во-первых, части выигрывают (упрощаются) за счёт того, что они пользуются частями более «низких» уровней («низкий» означает более низкий номер), во-вторых, мы можем отрезать верхние уровни и по прежнему иметь полезный продукт. Например, таблицу символов можно использовать в других приложениях, а модуль сохранения строк может быть основой системы ответов на вопросы. Существование иерархической структуры гарантирует, что мы можем "обрезать" верхние уровни дерева и начать растить новое новое дерево на старом стволе. Если бы мы разработали систему, в которой модули «низкого уровня» частично используют модули «высокого уровня», у нас не было бы иерархии, нам было бы гораздо труднее удалять части системы, а само понятие уровня в нашей системе было бы бессмыслено.

Поскольку вполне вероятно, что у нас могла бы быть система с первой декомпозицией (с важными проектными решениями об интерфейсах), но с сохранением иерархической структуры, мы можем сделать вывод о том, что иерархическая структура и «чистая» декомпозиция являются двумя важными, но *независимыми* свойствами структуры системы.

## Заключение

На разобранных примерах мы предприняли попытку показать, что начинать разделение системы на модули с блок-схемы почти всегда некорректно. Вместо этого мы предлагаем начинать со списка сложных проектных решений или же проектных решений, которые могут измениться в будущем. Каждый модуль предназначен для того, чтобы скрыть такое решение от других модулей. Поскольку в большинстве случаев проектные решения выходят за рамки времени выполнения программы, модули не будут соответствовать этапам её выполнения. Чтобы добиться эффективной реализации, мы должны отказаться от предположения о том, что модуль представляет собой одну или несколько подпрограмм, и вместо этого позволить подпрограммам брать код из других модулей.

> Принято в августе 1971; опубликовано в 1971

### Список литературы
1. Gauthier, Richard, and Pont, Stephen. *Designing Systems Programs*, (C), Prentice-Hall, Englewood Cliffs, N.J., 1970.
2. Hoare, C. A. R. Proof of a program, FIND. *Comm. ACM 14, 1* (Jan. 1971), 39-45.
3. Parnas, D. L. A technique for software module specification with examples. *Comm. ACM 15, 5* (May, 1972), 330-336.
4. Parnas, D. L. Information distribution aspects of design methodology. Tech. Rept., Depart. Computer Science, Carnegie-Mellon U., Pittsburgh, Pa., 1971. Also presented at the IFIP Congress 1971, Ljubljana, Yugoslavia.
5. Dijkstra, E. W. The structure of "THE"-multiprogramming system. *Comm. ACM 11, 5* (May 1968), 341-346.
6. Galler, B., and Perlis, A. J. *A View of Programming Languages*, Addison-Wesley, Reading, Mass., 1970.
7. Parnas, D. L. A course on software engineering. Proc. SIGCSE Technical Symposium, Mar. 1972.
8. Parnas, D. L. On the criteria to be used in decomposing systems into modules. Tech. Rept., Depart. Computer Science, Carnegie-Mellon U., Pittsburgh, Pa., 1971.
9. Balzer, R. M. Dataless programming. Proc. AFIPS 1967 FJCC, Vol. 31, AFIPS Press, Montvale, N.J., pp. 535-544.
10. Mealy, G. H. Another look at data. Proc. AFIPS 1967 FJCC, Vol. 31, AFIPS Press, Montvale, N.J., pp. 525-534.
11. Wulf, W. A., Russell, D. B., and Habermann, A. N. BLISS, A language for systems programming. *Comm. ACM 14, 12* (Dec. 1971), 780-790.

> Communications of the ACM
> Декабрь 1972
> Выпуск 15
> Номер 12